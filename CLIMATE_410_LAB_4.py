#!/bin/bash/env python3

# CLIMATE 410
# LAB #4 - HEAT DIFFUSION & PERMAFROST
# DUE 10/31/2024
# STUDENT NAME - LARS ANDERSLAND
# PULL REQUEST - LARA TOBIAS-TARSH

# improvements - docstring, break up code to take plotting out of main, add a convergence check
'''
Tools and methods for solving our heat equation/diffusion problem.

explores how forward differencing methdos can be used
to solve the heat equation with time in 1 dimension. We use this
heat diffusion equation model to answer questions about the seasonal
dynamics of permafrost and the impact of warming on permafrost in
the future.

To execute the code in this lab simply run:
```
    python CLIMATE_410_LAB_4.py
```

The simulation should immediately execute a unit test, which checks if the
heat difference solver runs successfully and print this to screen.

It should then run the experiments described in the lab manual for
Kangerlussuaq, producing a heat map and temperature profile for each.

'''
import numpy as np
import matplotlib.pyplot as plt

# Kangerlussuaq average temperature:
t_kanger = np.array([-19.7, -21.0, -17., -8.4, 2.3, 8.4,
10.7, 8.5, 3.1, -6.0, -12.0, -16.9])

def temp_kanger(t, offset_temp):
    '''
    For an array of times in days, return timeseries of temperature for
    Kangerlussuaq, Greenland.

    Parameters
    ----------
    t : np.ndarray
        array of times to interpolate temperatures to
    offset_temp : float 
        how much to offset the temperature by

    Return
    ------
        : np.ndarray
        array of temperatures interpolated to the unit in the solver
    '''
    t_amp = (t_kanger - t_kanger.mean()).max()
    return t_amp*np.sin(np.pi/180 * t - np.pi/2) + t_kanger.mean()+ offset_temp

def plot_results(tgrid,xgrid,U,dt,offset_temp,file_prefix):
    """
    Plotting function to create a heatmap and vertical profile of the data
    generated by the heatdiff solver.

    Parameters
    ----------
    tgrid : np.ndarray
        Array of time values
    xgrid : np.ndarray
        Array of spatial points in the ground
    U : np.ndarray
        2D array of calculated temperatures at each spatial and temporal point, representing 
        the temperature profile over time and depth.
    dt : float
        timestep used in the heatdiff solver
    offset_temp : float
        amount by which the climate curves are offset
    file_prefix : string
        string to use in filepath for the output
    """
    # PLOT #1 = Space-Time Heat Map
    # Setting up plot, axes, and labels
    fig, ax1 = plt.subplots(1, 1)
    # TO DO: change map so not redefining python map function
    colormap = ax1.pcolor(tgrid / 365, xgrid, U, cmap='seismic', vmin=-25, vmax=25)
    ax1.set_title('Ground Temperature: Kangerlussuaq, Greenland')
    ax1.set_xlabel('Time (Years)', fontsize = 14)
    ax1.invert_yaxis()
    ax1.set_ylabel('Depth (m)', fontsize = 14)
    plt.figtext(0.5, -0.04, f"Temperature Offset: {offset_temp}°C", ha="center", fontsize=12)
    plt.colorbar(colormap, ax=ax1, label='Temperature ($C$)')
    fig.savefig(f"{file_prefix}_heat_map.png", dpi=300, bbox_inches='tight')
    
    # PLOT #2 = Seasonal Temperature Profiles
    # Set indexing for final year (i.e. finding how many timesteps are in a year)
    loc = int(-365 / dt) 
    # Extracting min values as winter
    winter = U[:, loc:].min(axis=1)
    # Extracting max values as summer
    summer = U[:, loc:].max(axis=1)
    
    # Identify the active layer depth (first point where summer temperature transitions from positive to negative)
    active_layer_depth, permafrost_depth = None, None
    # Simplified previous double loop into single loop
    # Still goes through and checks for below zero using linear interpolation
    for i,_ in enumerate(summer):
        
        if active_layer_depth is None and i > 0 and summer[i] < 0 and summer[i-1] > 0:
            depth1, depth2 = xgrid[i-1], xgrid[i]
            temp1, temp2 = summer[i-1], summer[i]
            active_layer_depth = depth1 + (0 - temp1) * (depth2 - depth1) / (temp2 - temp1)

        # Check for permafrost depth
        if abs(summer[i]) < 1e-2 and permafrost_depth is None:
            permafrost_depth = xgrid[i]

        if active_layer_depth is not None and permafrost_depth is not None:
            break

    # Setting up plot, axes, and labels
    fig, ax2 = plt.subplots(1, 1, figsize=(10, 8))
    ax2.plot(winter, xgrid, label='Winter')
    ax2.plot(summer, xgrid, label='Summer', linestyle='--')
    plt.gca().invert_yaxis()  
    ax2.set_xlim(-8, 6)
    ax2.set_ylim(100, 0)
    ax2.set_xlabel('Temperature (°C)', fontsize = 14)
    ax2.set_ylabel('Depth (m)', fontsize = 14)
    plt.figtext(0.5, 0.01, f"Time Elapsed: {len(tgrid)/365:.2f} Years | Temperature Offset: {offset_temp}°C", 
            ha="center", fontsize=12)
    ax2.set_title('Ground Temperature: Kangerlussuaq')
    # Enabling the gridlines shown in the lab manual
    ax2.set_xticks(np.arange(-8, 8, 2))
    ax2.set_yticks(np.arange(0, 110, 10))  
    ax2.grid(True)  

    # Plot the active and permafrost layer depths if found (NOTE: there were edge cases (extremely small
    # or large tmax)where my algorithm here didn't find one, which is why I have the conditions
    if active_layer_depth is not None:
        ax2.plot(0, active_layer_depth, 'ro', label='Active Layer Depth')
        ax2.text(0.2, active_layer_depth, f'{active_layer_depth:.2f} m', 
                ha='left', va='center', color='red', fontsize=14)
    if permafrost_depth is not None:
        ax2.plot(0, permafrost_depth, 'bo', label='Permafrost Depth')
        ax2.text(0.2, permafrost_depth, f'{permafrost_depth:.2f} m', 
                ha='left', va='center', color='blue', fontsize=14)
        
    ax2.legend()
    fig.savefig(f"{file_prefix}_seasonal_profile.png", dpi=300, bbox_inches='tight')

def heatdiff(xmax, tmax, dx, dt, offset_temp, file_prefix, *args,
             upper_bounds=temp_kanger, lower_bounds=5, init=0, c2=.0216, debug=False, plot=True, **kwargs):
    '''
    Simulates heat diffusion through the ground using the forward difference method.

    Parameters:
    -----------
    xmax : float
        Maximum depth in meters
    tmax : float
        Maximum time in days
    dx : float
        Step size in meters
    dt : float
        Time step in seconds
    offset_temp : float
        Offset value for the temperature at the surface boundary, which is applied in the 
        surface boundary condition using the Kangerlussuaq heating equation.
     file_prefix : str, optional
        Prefix for the filenames of the output .png files.
    c2 : float, optional
        Thermal diffusivity constant (default = 1). It defines how quickly heat diffuses 
        through the medium.
    debug : bool, optional
        If True, prints information about the grid and numerical details (default is False).
    validation_case : bool, optional
        If True, uses a specific set of initial and boundary conditions for validation purposes 
        (default is False). 

    Returns:
    --------
    xgrid : ndarray
        Array of spatial points in the ground
    tgrid : ndarray
        Array of time values
    U : ndarray
        2D array of calculated temperatures at each spatial and temporal point, representing 
        the temperature profile over time and depth.

    MISC Notes:
    ------
    - The function checks for numerical stability based on checking `dt <= dx^2 / (2 * c2)`. 
      If the not met, the function prompts the user to retry with smaller time or depth steps.
    - Enables doing either the validation or nonvalidation case via parameter input
    - The function also generates and saves two plots:
        1. A space-time heat map showing the temperature variation over time and depth.
        2. Seasonal temperature profiles at the maximum time step, displaying the temperature distribution 
        in winter and summer. Active and permafrost layer depths are estimated and visualized.
    '''
    # Checking for numerical stability
    if(dt > (dx**2 / (2 * c2))):
        # raise value error if numerically unstable
        raise(ValueError('your selected time and depth steps result in numerically unstable behavior.'
                         f'Please retry with steps so that dt <= (dx^2) / (2 * c2). dt : {dt}, dx : {dx}'))

    # Start by calculating size of array: MxN
    M = int(np.round(xmax / dx + 1))
    N = int(np.round(tmax / dt + 1))

    # IDEA = creates arrays for the axes
    xgrid, tgrid = np.arange(0, xmax+dx, dx), np.arange(0, tmax+dt, dt)

    # Initialize our data array:
    U = np.zeros((M,N))

    # Debug or Validation Case Condition Printing Out Grids
    if debug:
        print(f'There are {M} points in space and {N} points in time.')
        print('Temperature array U in grid format:')
        # array2string to make the precision exactly match what's in the lab manual
        # documentation: https://numpy.org/devdocs/reference/generated/numpy.array2string.html
        print(np.array2string(U, formatter={'float_kind': lambda x: f"{x:.7f}" if x < 0.1 else f"{x:.6f}"
                                         if x < 0.2 else f"{x:.5f}" if x < 0.5 else f"{x:.3f}"}))

    # Setting Initial and Boundary Conditions
    U[:,0] = init(xgrid,*args,**kwargs) if callable(init) else init
    U[0, :] = upper_bounds(tgrid,offset_temp,*args,*kwargs) if callable(upper_bounds) else upper_bounds
    U[-1, :] = lower_bounds(*args,kwargs) if callable(lower_bounds) else lower_bounds
    
    # Set our "r" constant.
    r = c2 * dt / dx**2

    # Solve! Forward differnce ahoy.
    # IDEA = for each time step, solve for all of the corresponding 
    # spatial values (except the bounday conditions)
    for j in range(N-1):
        U[1:-1, j+1] = (1-2*r) * U[1:-1, j] + \
            r*(U[2:, j] + U[:-2, j])

    if plot:
        plot_results(tgrid,xgrid,U,dt,offset_temp,file_prefix)
    # Return grid and result:
    return xgrid, tgrid, U

def unit_test(U):
    """
    Function completes a unit test to verify if the solver
    is working correctly. Does this using the solution given 
    in the lab manual. Uses the wire test problem.

    Will print if the test passes or fails.

    Parameters
    ----------
    U : np.ndarray
        numpy array representing the heat in the wire with time
    """
    # Solution to problem 10.3 from fink/matthews as a nested list:
    sol10p3 = [[0.000000, 0.640000, 0.960000, 0.960000, 0.640000, 0.000000],
        [0.000000, 0.480000, 0.800000, 0.800000, 0.480000, 0.000000],
        [0.000000, 0.400000, 0.640000, 0.640000, 0.400000, 0.000000],
        [0.000000, 0.320000, 0.520000, 0.520000, 0.320000, 0.000000],
        [0.000000, 0.260000, 0.420000, 0.420000, 0.260000, 0.000000],
        [0.000000, 0.210000, 0.340000, 0.340000, 0.210000, 0.000000],
        [0.000000, 0.170000, 0.275000, 0.275000, 0.170000, 0.000000],
        [0.000000, 0.137500, 0.222500, 0.222500, 0.137500, 0.000000],
        [0.000000, 0.111250, 0.180000, 0.180000, 0.111250, 0.000000],
        [0.000000, 0.090000, 0.145625, 0.145625, 0.090000, 0.000000],
        [0.000000, 0.072812, 0.117813, 0.117813, 0.072812, 0.000000]]
    
    # Convert to an array and transpose it to get correct ordering:
    sol10p3 = np.array(sol10p3).transpose()
    if np.sum(U-sol10p3) <= 1E-8:
        print('Unit Test Passed - correct values relative to test solution')
    else:
        print('Warning - Unit Test Failed! Check solver equations.')

def test_unstable():
    """
    Unit test to show a warning is raised if unstable initial conditions are
    passed into the function.
    """
    try:
        heatdiff(xmax=100,tmax=1825,dx=2,dt=100,offset_temp=0,file_prefix='',plot=False)
    except ValueError:
        print('Unit Test Passed - Value error for unstable conditions caught')
    else:
        print('Unstable conditions not caught by solver, check equations.')

def question_one():
    """
    Runs the experiments for question 1 in the lab,
    running the unit test and then the first experiment in the lab.

    To check for convergence while staying close to the source code,
    this runs for 5, 10, 20, 30 and 50 years respectively.

    Produces a heat map and vertical profile for each.
    """
    _, _, U_test = heatdiff(xmax=1.0,tmax=0.2,dx=0.2,dt=0.02,offset_temp=0,file_prefix='',
             upper_bounds=lambda x,y: 4*x - 4*x**2,lower_bounds=0,c2=1,plot=False)
    unit_test(U_test)

    # now run the simulation out and plot each experiment
    _,_,_ = heatdiff(xmax=100,tmax=365*5,dx=0.5,dt=1,offset_temp=0,file_prefix='Q2.1',plot=True)   # 5 yrs
    _,_,_ = heatdiff(xmax=100,tmax=365*10,dx=0.5,dt=1,offset_temp=0,file_prefix='Q2.2',plot=True)  # 10 yrs
    _,_,_ = heatdiff(xmax=100,tmax=365*20,dx=0.5,dt=1,offset_temp=0,file_prefix='Q2.3',plot=True)  # 20 yrs
    _,_,_ = heatdiff(xmax=100,tmax=365*30,dx=0.5,dt=1,offset_temp=0,file_prefix='Q2.4',plot=True)  # 30 yrs
    _,_,_ = heatdiff(xmax=100,tmax=365*50,dx=0.5,dt=1,offset_temp=0,file_prefix='Q2.5',plot=True)  # 50 yrs
    
def question_two():
    """
    Runs the experiments for question 2 in the lab,
    running the unit test and then the second experiment the lab.

    Runs each shift for 30 and 50 years in order to try and stay a bit
    closer to the source code, though would argue this could just be run
    for 50 years.

    Produces a heat map and vertical profile for each.
    """

    # 0.5 degree C shift
    _,_,_ = heatdiff(xmax=100,tmax=365*30,dx=0.5,dt=1,offset_temp=.5,file_prefix='Q3.1',plot=True)
    _,_,_ = heatdiff(xmax=100,tmax=365*50,dx=0.5,dt=1,offset_temp=.5,file_prefix='Q3.2',plot=True)
    # 1.0 degree C shift
    _,_,_ = heatdiff(xmax=100,tmax=365*30,dx=0.5,dt=1,offset_temp=1.,file_prefix='Q3.3',plot=True)
    _,_,_ = heatdiff(xmax=100,tmax=365*50,dx=0.5,dt=1,offset_temp=1.,file_prefix='Q3.4',plot=True)
    # 3.0 degree C shift
    _,_,_ = heatdiff(xmax=100,tmax=365*30,dx=0.5,dt=1,offset_temp=3.,file_prefix='Q3.5',plot=True)
    _,_,_ = heatdiff(xmax=100,tmax=365*50,dx=0.5,dt=1,offset_temp=3.,file_prefix='Q3.5',plot=True)
    

    
# main definition
def main():
    # NOTE: all plots were deleted before uploading to Github
    # NOTE: due to computation time, do NOT try running all lines here at once.
    # Instead, comment out all the ones you don't want to run, running one or two at a time
    test_unstable()
    question_one()  # run question 1 (unit test and baseline)
    question_two()  # run question 2 (climate shifts)


# main() driver
if __name__ == "__main__":
    main()
    